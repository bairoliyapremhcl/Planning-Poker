<!DOCTYPE html>
<html>
<head>
    <title>PlanningGame</title>

    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                
Ext.define('Niks.Apps.TeamPicker', {
    constructor: function() {
        this.callParent();
    }
});

Ext.define('Niks.Apps.PlanningGame', {
    extend: 'Rally.app.App',
    componentCls: 'app',

    //Only save the least amount of data in here. We only have 32768 chars to play with
    _GC: {},

    config: {
        configFieldName: "c_PlanningPokerConfig",
        configSplitter: '^'
    },

    statics: {
        SAVE_FAIL_RETRIES: 5
    },

    listeners: {
        configchanged: function() {
            this._saveProjectConfig().then({
                success: function() {
                    /** Config saved and restart from scratch */
                    this._reloadGame();
                },
                failure: function(e) {
                    console.log("Failed to save project config",e);
                },
                scope: this
            });
        },
        refresh: function() {
            Rally.ui.notify.Notifier.show({message: 'Refreshing Game'});
            this._getProjectConfig().then( {
                success: function() {
                    debugger;
                }
            });
        },
        showConfig: function() {
            if (this._iAmModerator()){
                this._GC.showPanel();
            }
        }
    },

    _reloadGame: function() {
        /** Clear out existing data and settings 
         * We will need to refetch the config from the project 
         * */

        this._UC.restart();
        this._kickOff();
    },

    _iAmModerator: function() {
        return this.getContext().getUser().ObjectID === this._GC.getModerator().get('ObjectID');
    },

    _setUpUserScreen: function() {
        //Check for whether we are the moderator
        var iAmMod = this._iAmModerator();
        var page = this._UC.getPanel(iAmMod);
        this._UC.addStories(iAmMod?this._storyStore.getRecords():null);
        page.show();
    },

    _kickOff: function() {
        var me = this;
        /** When we come here, everything should be in place to start a new game
         * Now fetch the User Stories - with the option of only those not sized yet
         */
        this._getCurrentIteration().then({
            success: function(iteration) {
                var filters = [{
                    property: 'Iteration',
                    value: iteration.get('_ref')
                }];

                if (me._GC.onlyUnSizedStories()) {
                    filters.push( Rally.data.wsapi.Filter.or(
                    [
                        {
                            property: 'PlanEstimate',
                            operator: '=',
                            value: null
                        },
                        {
                            property: 'PlanEstimate',
                            operator: '=',
                            value: 0
                        }
                    ]));
                    filters = Rally.data.wsapi.Filter.and(filters);
                }

                me._storyStore = Ext.create('Rally.data.wsapi.Store', {
                    model: 'HierarchicalRequirement',
                    filters: filters,
                    context: {
                        projectScopeUp: false,
                        projectScopeDown: false
                    },
                    autoLoad: true,
                    listeners: {
                        load: function(store, records, success) {
                            if (success) {
                                Rally.ui.notify.Notifier.show({message: Ext.String.format("Loaded {0} stories", records.length)});
                                me._setUpUserScreen();
//                                me._GC.showPanel();
                            }else {
                                Rally.ui.notify.Notifier.showWarning({message: "No stories found in this iteration/project node"});
                            }
                        },
                        scope: me
                    }
                });
            },
            failure: function(e) {
                console.log("Didn't find a 'current' iteration", e);
            }
        });

    },

    _loadGameConfig: function() {
        var me = this;

        /** We need to load up the project specific config now.
         * Firstly, we need the team members
         */
        var record = this.projectStore.getRecords()[0];
        if ( record.get('TeamMembers').Count > 0) {
            record.getCollection('TeamMembers').load( {
                fetch: true,
                callback: function( members, operation, success) {
                    //Add all the team members to the GameConfig
                    if (success === true) {
                        Rally.ui.notify.Notifier.show({ message: "Team members loaded"});
                        _.each(members, function(member) {
                            me._UC.addUser(member);
                        });
                        me._kickOff();
                    }
                    else {
                        console.log("Team members field unavailable");
                    }
                },
                scope: me
            });
        }
        else {
            Rally.ui.notify.Notifier.showWarning({ message: "Team members not configured"});
        }

    },

    launch: function () {
        var me = this;
        me._GC = Ext.create('Niks.Apps.PokerGameConfig', {
            app: me,
            project: me.getContext().getProject()
        });

        me._UC = Ext.create('Niks.Apps.PokerUserConfig', {
            app: me,
            project: me.getContext().getProject()
        });

        //Check for required fields in this project node

        //Create config page and then pull config from project node if exists. If not, create.
        //If not config already, ask the user if they are to be the Moderator for this.

        /** Set up a timer that reads the config every 1sec so that we pull changes from other users
         * 
         */

        this._checkProjectFieldConfig().then( {
            success: function() {   //Just need to get the store next
                this._getProjectConfig().then({
                    success: function(projConfig) {
                        if (projConfig.hasOwnProperty("moderatorID")){
                            // Ready to go
                            //get the moderator from the saved config ID and give it to the gameConfig to fetch the full user
                            me._GC.setModeratorFromId(projConfig.moderatorID). then ({
                                success: function() {
                                    me._loadGameConfig();
                                },
                                failure: function() {
                                    console.log('Failed to set moderator from ID');
                                }
                            });
                        }
                        else {
                            //Set up new config
                            Ext.create('Rally.ui.dialog.ConfirmDialog', {
                                title: "New Config",
                                message: "Are you moderator for this session?",
                                listeners: {
                                    confirm: function() {
                                        //Set user up as moderator
                                        me._GC.setModerator( me.getContext().getUser());
                                        me._saveProjectConfig().then({
                                            success: function() {
                                                /** Config saved and we are ready to go */
                                                me._loadGameConfig();
                                            },
                                            failure: function(e) {
                                                console.log("Failed to save project config",e);
                                            },
                                            scope: me
                                        });
                                    }
                                }
                            });
                        }
                    },
                    failure: function(e) {
                        console.log(e);
                    },
                    scope: me
                });
            },
            failure: function(e) {
                console.log(e);
            },
            scope: me
        });

    },

    _createStoryBrowser: function() {
        var deferred = Ext.create("Deft.Deferred");
        return deferred.promise;

    },

    _createUserMenu: function() {
        /** Each user must have a way to save and restore their current settings/layout */
        var deferred = Ext.create("Deft.Deferred");
        return deferred.promise;

    },

    _createLeadMenu: function() {
        /** Lead menu must have access to the config page */
        var deferred = Ext.create("Deft.Deferred");
        return deferred.promise;

    },

    /** Make sure that the system is set up the way we need */
    _checkProjectFieldConfig: function() {
        var me = this;
        //Check field PlanningConfig exists on project model
        var deferred = Ext.create("Deft.Deferred");

        Rally.data.ModelFactory.getModel({
            type: "Project",
            fetch: true,
            success: function(model) {
                //Add any prechecks here
                if (model.hasField(me.configFieldName)) {
                    deferred.resolve(model);
                } else {
                    //Here, we need to ask if they want to set up the new field (need to be workspace admin)
                    deferred.reject("Correct Config not available");
                }
            },
            failure: function() {
                //Shouldn't happen unless Rally is down
                deferred.reject("Failed to get Project Model");
            }
        });
        return deferred.promise;
    },

    /** As the game progresses, we need to save the state of the game. 
     * We will need to do retries due to concurrency errors that we might get with a number
     * of people trying to update the same field on the Project.
     * 
     * We also will need to be able to reload the last config to get back to where we were 
     * in the game before, if there is ever any issues (browser crash, network error, etc., etc.)
     *  For this, we should put a "refresh" button on the top menu bar
    */
    
    _getProjectConfig: function() {   /** parameter provided is Project Model, but not the actual data */
        var me = this;
        var deferred = Ext.create("Deft.Deferred");
        /** 
         * The current context should contain the Project record that we are currently at. 
         * We could change this to be a project picker if that becomes a useful feature.
         * Even if we update the Project field, then the environment keeps that handily local.
        */
        var project = this.getContext().getProject();
        me.projectStore = Ext.create( 'Rally.data.wsapi.Store', {
            model: 'Project',
            filters: [{
                property: 'ObjectID',
                value: project.ObjectID
            }],
            autoLoad: true,
            fetch: true,
            listeners: {
                load: function(store, records) {
                    me._GC.initialiseConfig(records[0].get(this.configFieldName));
                    var currentConfig = me._GC.getNamedConfig(mainConfigName);
                    deferred.resolve(currentConfig);
                },
                scope: me
            }
        });

        return deferred.promise;
    },

    _failedSave: 0,

    /** Save the current config */
    _saveProjectConfig: function(existingDefer) {
        var me = this;
        var deferred = (existingDefer === undefined) ? Ext.create("Deft.Deferred") : existingDefer;
        var currentConfig = this._GC.getGameConfig();

        var record = this.projectStore.getRecords()[0];
        record.set(this.configFieldName, currentConfig);
        record.save({
            success: function() {
                this._failedSave = 0;
                Rally.ui.notify.Notifier.show({ message: "Config Saved to Project"});
                deferred.resolve();
            },
            failure: function() {
                if (this._failedSave < this.self.SAVE_FAIL_RETRIES) {
                    this._saveProjectConfig(deferred);
                }
                else {
                    deferred.reject("Failed to save Project Config");
                }
            },
            scope: me
        });
        return deferred.promise;
    },

    _checkConfigChange: function(newConfig) {
        console.log(newConfig);
    },

    //Create and hide the config page
    _createConfigPage: function() {
        /** Config page must have:
         * 1. Moderator Chooser
         * 2. Team member list - enables for this session
         * 3. Timer countdown duration
         * 4. Iteration for this session
         */
        var deferred = Ext.create("Deft.Deferred");
        return deferred.promise;
    },

    /** Make the main pages that the game players need
     * 
     */
    _createUserPage: function() {
        var deferred = Ext.create("Deft.Deferred");
        return deferred.promise;
    },

    _createLeadPage: function() {
        var deferred = Ext.create("Deft.Deferred");
        return deferred.promise;
    },

    _getCurrentIteration: function() {

        /** In this project, find the iteration that is ongoing */
        var deferred = Ext.create("Deft.Deferred");

        this._iterationStore = Ext.create('Rally.data.wsapi.Store', {
            model: 'Iteration',
            autoLoad: true,
            context: {
                projectScopeUp: false,
                projectScopeDown: false
            },
            filters: [
                {
                    property: "StartDate",
                    operator: "<",
                    value: new Date()
                },
                // {
                //     property: 'EndDate',
                //     operator: ">",
                //     value: new Date()
                // }
            ],
            sorters: [
                {
                    property: 'StartDate',
                    direction: 'DESC'
                }
            ],
            listeners: {
                load: function(store, records, success) {
                    if (success) {
                        deferred.resolve(records[0]);
                    }
                    else {
                        Rally.ui.notify.Notifier.show({message: 'No appropriate Iterations available'});
                    }
                }
            }
        });
        return deferred.promise;
    },
});

                /** Event Passing */
const modChange = 'moderatorchanged';
const configChange = 'configchanged';

/** Configuration naming  */
const mainConfigName = 'MainConfig';
const userConfigName = 'UserConfig';
const iterConfigName = 'IterConfig';

/* Display card  */

const cardWidth = 200;
const cardHeight = 400;
const cardMargin = 10;
const cardSizeField = 'PlanEstimate';
const cardIdField = 'FormattedID';

/** Configuration utils */

const configSplitter1 = '^';
const configSplitter2 = '|';
                Ext.define('Niks.Apps.Panel', {

    bubbleEvents: [],

    constructor: function(config) {
        //this.callParent(arguments);
        Ext.applyIf(this, config);
    },

    getPanel: function(param) {
        return this.configPanel || this._createPanel(param);
    },

    showPanel: function() {
        this.getPanel().show();
    },

    hidePanel: function() {
        this.getPanel().hide();
    },

});

                
Ext.define('Niks.Apps.PokerGameConfig', {
    extend: Niks.Apps.Panel,

    /** Each interation might have different config
    iterationConfig: {}, 
    */
   /**
    mainConfig: {
        activeStory: null,
        moderatorID: null,
        onlyUnsized: false,
    },
     */
    /** 
    userConfig: {}, //Contains 'active' as well as other layout info for this game 
     */

    userIDs: [],            /** Only contains the reference to the user only so that we can get info from UserConfig */
    moderatorUser: null,    /** Full object for the moderator */
    
    statics: {
        userIdField: "ObjectID"
    },

    /** We know of three config types right now: MainConfig, IterationConfig, UserConfig */
    initialiseConfig: function(fieldText) {
        this[mainConfigName] = this._decodeConfig(mainConfigName, fieldText);
        this[userConfigName] = this._decodeConfig(userConfigName, fieldText);
        this[iterConfigName] = this._decodeConfig(iterConfigName, fieldText);
    },

    getNamedConfig: function(name) {
        return this[name] || {};
    },

    _decodeConfig: function(requiredType, fieldText) {

        if ((fieldText === undefined) || ( fieldText.length === 0)) {
            return {};
        }
        var msgs = fieldText.split(configSplitter1);
        var configs = {};
        _.each(msgs, function(msg) {
            var splitMsg = msg.split(configSplitter2);
            if (splitMsg[0].length) {
                configs[splitMsg[0]] = splitMsg[1];
            }
        });
        return JSON.parse(configs[requiredType] || "{}");
    },

    addUser: function(user) {   //Passed in a user record
        if ( _.find( this.userIDs, {userOID: user.get(this.self.userIdField)})) {
            console.log("Adding existing member - ignoring!");
        } else {
            this.userIDs.push(user[this.self.userIdField]);
        }
    },

    getModerator: function() {
        if (this.moderatorUser) {
            return this.moderatorUser;
        }
        else return null;   //Be specific about a null.
    },

    setModerator: function(user) {
        this[mainConfigName].moderatorID = user.get(this.self.userIdField);
        this.moderatorUser = user;
    },

    setModeratorFromId: function(id) {
        var me = this;
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.wsapi.Store', {
            model: 'User',
            autoLoad: true,
            filters: [
                {
                    property: this.self.userIdField,
                    value: id
                }
            ],
            listeners: {
                load: function(store, records, success) {
                    if (success) {
                        me.setModerator(records[0]);
                        deferred.resolve(records[0]);
                    }
                    else {
                        deferred.reject();
                    }
                }
            }
        });
        return deferred.promise;
    },

    onlyUnSizedStories: function() {
        return this[mainConfigName].onlyUnsized;
    },

    _encodeMsg: function(msgType, msgText) {
        return configSplitter1 + msgType + configSplitter2 + msgText;
//        return configSplitter + msgType + "," + window.btoa(msgText);
    },

    _decodeMsg: function(msgType, msgText) {
        return msgText.split(configSplitter2).pop();
    },

    /* Gameconfig is the thing that is stored to the Project field. Must not be more than 32768 chars */
    getGameConfig: function() {
        return  this._encodeMsg(mainConfigName, JSON.stringify(this[mainConfigName])) +
                this._encodeMsg(userConfigName, JSON.stringify(this[userConfigName]))+
                this._encodeMsg(iterConfigName, JSON.stringify(this[iterConfigName]));
    },

    _createPanel: function() {
        var me = this;
        var panel = Ext.create('Ext.panel.Panel', {
//        var panel = Ext.create('Ext.container.Container', {
            floating: true,
            width: 400,
            height: 400,
            baseCls: 'configPanel',
            hidden: true,
            closable: true,
            closeAction: 'hide',
        });
        panel.add( {
            xtype: 'field',
            id: 'curMod',
            fieldLabel: 'Current Moderator',
            labelWidth: 200,            
            margin: '10 0 10 20',
            baseBodyCls: 'textfield',
            readOnly: true,
            value: me.moderatorUser? me.moderatorUser.get('UserName'): 'Not Set'

        });
        panel.add( {
            xtype: 'rallyusercombobox',
            id: 'modChooser',
            fieldLabel: 'Change Moderator To',
            valueField: this.self.userIdField,
            labelWidth: 200,
            margin: '10 0 10 20',
            autoSelect: false,
            listeners: {
                //Setvalue fires when the thing is first set up with a null value.
                setvalue: function(entry) {
                    if (entry.value !== null) {
                        me.setModerator(entry.lastSelection[0]);
                        panel.down('#curMod').setValue(me.moderatorUser.get('UserName'));
                        Ext.create('Rally.ui.dialog.ConfirmDialog', {
                                title: "New Moderator",
                                message: "Restart session?",
                                listeners: {
                                    confirm: function() {
                                        //Set user up as moderator
                                        me.app.fireEvent(configChange);
                                        me.hidePanel();
                                    }
                                }
                            }
                        );
                    }
                },
            }
        });

        panel.add( {
            xtype: 'rallycheckboxfield',
            fieldLabel: "Fetch Unsized Only",
            id: 'unsizedOnly',
            value: me[mainConfigName].onlyUnsized,
            labelWidth: 200,
            margin: '10 0 10 20',
            listeners: {
                change: function( tickbox, newV, oldV, opts) {
                    me[mainConfigName].onlyUnsized = newV;
                    me.app.fireEvent(configChange)
                }
            }
        });

        this.configPanel = panel;
        return panel;
    },
});
                /** Something to hold the current config of the user during this session
 * 
 */

Ext.define('Niks.PokerCard', {
    extend: Ext.panel.Panel,
    margin: cardMargin,
    layout: 'vbox',

    constructor: function(config) {
        Ext.apply(this.config);
        this.callParent(arguments);
        var ls = this.card.get(cardSizeField);
        ls = (ls === null)?(ls === 0?'set to zero':'not set'):ls.toString();
//        console.log('Card: ', this.card.get(cardIdField), ' set to ', ls);
        this.add(
            {
                xtype: 'text',
                text:  "Current Size: " + ls 
            }
        );
    },

    config: {},

    // initComponent: function() {
    //     this.callParent(arguments);
    // }
});


Ext.define('Niks.Apps.PokerUserConfig', {
    extend: Niks.Apps.Panel,
    users: [],
    valueSeries: [0,1,2,3,5,8,13,20,50,100],
    stories: [],

    /* This is called from something that has got a Store record not just a model */
    addUser: function(userRecord) {
        /** Check if the user is in the array. If not, then add */
        if (!_.find(this.users, function(user) {
            if (userRecord.get('ObjectID') === user.get('ObjectID')) {
                return true;
            }
        })){
            this.users.push(userRecord);
        }
    },

    getModeratorPanel: function() {

    },

    restart: function() {
        this.stories = [];
        this.down('#cardspace').removeAll();
    },

    //Stories can come as the form of the records in a store or the valueSeries
    addStories: function( stories ) {
        var me = this;
        if (stories === null) {
            //Add the cards from the valueSeries because we are a standard user
        }
        else {
            _.each(stories, function(story) {
                me._addCardToPage(story);
            })
            //Add the moderators story cards
        }
    },

    _addCardToPage: function(story) {

        if ( _.find(this.stories, function(savedStoryID) {
                return story.get(cardIdField) === savedStoryID;
        })) {
            return;
        }
        this.stories.push(story.get(cardIdField));
        var page = this.getPanel();

//        var subpage = this.userOrModerator? 'discussion':'details';
       var cs = page.down('#cardspace');
        cs.add(Ext.create('Niks.PokerCard', {
            title: Ext.String.format('<a target="_blank" href={1}>{0} </a><a target="_blank" href={2} class="icon-chat"></a>', 
                        story.get(cardIdField), 
                        Rally.nav.Manager.getDetailUrl(story, {subPage: ''}),
                        Rally.nav.Manager.getDetailUrl(story, {subPage: 'discussion'})),
            width: cardWidth,
            height: cardHeight,
            card: story
        }));
    },

    //Singleton that never dies..... hopefully....
    _createPanel: function(userOrModerator) {   //0 = user, !0 = mod
        var me = this;
        this.userOrModerator = userOrModerator;

        var page = me.configPanel = Ext.create('Ext.container.Container', {
            width: '100%',
            height: 'auto',
            layout: 'hbox',
            id: 'userPage',
            items: [
                {
                    xtype: 'container',
                    id: 'menu',
                    width: 100,
                    margin: cardMargin,
                    cls:'clearpanel'
                },
                {
                    xtype: 'container',
                    id: 'cardspaceparent',
                    width: '50%',
                    flex: 1,
                    cls:'clearpanel'
                },
                {
                    xtype: 'container',
                    id: 'actions',
                    width: 400,
                    cls:'clearpanel'
                }
            ]
        });

        me.app.add(page);

        var cs = page.down('#cardspaceparent');
        cs.removeCls('x-panel-body-default');
        var numcols = Math.floor(cs.getWidth()/(cardWidth+(2*cardMargin)));
        numcols = (numcols>0)? numcols: 1;
        cs.add( {
            xtype: 'panel',
            id: 'cardspace',
            margin: 10,
            layout: {
                type: 'table',
                columns: numcols
            },
            bodyCls: 'userpanel',
        });

        if (this.userOrModerator) {
            page.down('#menu').add({
                xtype: 'rallybutton',
                width: 100,
                text: 'Config',
                margin: '10 10 0 10',
                handler: function() {
                    me.app.fireEvent('showConfig');
                }
            });
        }
        page.down('#menu').add({
            xtype: 'rallybutton',
            width: 100,
            text: 'Refresh',
            margin: '10 10 0 10',
            handler: function() {
                me.app.fireEvent('refresh');
            }
        });

        return page;
    }

});

            Rally.launchApp('Niks.Apps.PlanningGame', {
                name:"PlanningGame",
                parentRepos:"",
                version:"0.1.1"
            });

        });
    </script>



    <style type="text/css">
        .userpanel {
  border-top: 1px solid black;
  border-left: none;
  border-right: none;
  border-bottom: none;
  background-color: palegoldenrod;
}
.clearpanel {
  border: none;
}
.configPanel {
  opacity: 1;
  background-color: palegoldenrod;
}
.textfield {
  border-style: none none solid none;
  border-color: black;
  border-width: 1px;
}

    </style>
</head>
<body>
</body>
</html>
